# GOODMETER - Claude Context File

**Last Updated**: 2026-02-27
**Developer**: MediaStorm
**AI Assistant**: Claude (Sonnet 4.5)
**Identity Verification Code**: 2601129137

---

## Project Overview

**GOODMETER** is a professional audio metering VST3/AU plugin inspired by Mini Meter and iZotope Insight 2. It provides comprehensive loudness and stereo field analysis for mixing and mastering engineers.

### Design Philosophy
- **UI Design**: Gemini (Goodhertz/FabFilter aesthetic)
- **DSP/JUCE Implementation**: Claude (thread-safe, real-time algorithms)
- **Division Reason**: Previous SPLENTA aesthetic incident (æ·«çº¹äº‹ä»¶) ðŸ˜…

---

## Technical Architecture

### DSP Engine (PluginProcessor)
- **Thread Safety**: Lock-free atomics + FIFO, no allocation in processBlock
- **K-Weighting**: ITU-R BS.1770-4 (38Hz HP + 1500Hz HS +4dB)
- **LUFS Buffer**: 32768 samples (400ms window at 48kHz)
- **FFT**: 4096 points with Hann windowing
- **Metrics**: Peak, RMS, LUFS, Phase Correlation, M/S

### UI Framework (PluginEditor)
- **Framework**: JUCE C++ (migrated from React/Canvas)
- **Update Rate**: 60Hz Timer
- **Components**: 7 meter modules (LEVELS, VU, 3-BAND, SPECTRUM, PHASE, STEREO, SPECTROGRAM)
- **Aesthetics**: Deep blacks (#2A2A35), bold colors (#E6335F, #FFD166), thick borders

---

## Development Phases

### âœ… Phase 0: Design (2026-01-27)
- Gemini designed complete UI with 7 metering modules
- Established 5 loudness standards (EBU R128, ATSC A/85, ITU-R BS.1770-4, AES Streaming, Custom)

### âœ… Phase 1: DSP Foundation (2026-02-27)
- Implemented PluginProcessor.h with lock-free FIFO and K-Weighting filter
- Implemented PluginProcessor.cpp with all metering algorithms
- Verified thread-safety and real-time compliance

### ðŸ”„ Phase 2: UI Foundation (IN PROGRESS)
- Create custom LookAndFeel with color palette
- Build MeterCardComponent with collapsible functionality
- Set up 60Hz Timer in PluginEditor

### Phase 3: Component Translation (PENDING)
- Migrate React/Canvas meters to JUCE Components
- Start simple: Levels.tsx, ClassicVUMeter.tsx
- End complex: StereoFieldAnalyzer.tsx, PhaseCorrelation.tsx

---

## File Structure

```
GOODMETER/
â”œâ”€â”€ Source/                    # JUCE C++ code
â”‚   â”œâ”€â”€ PluginProcessor.h      # DSP engine (âœ… Phase 1 complete)
â”‚   â”œâ”€â”€ PluginProcessor.cpp    # (âœ… Phase 1 complete)
â”‚   â”œâ”€â”€ PluginEditor.h         # Main UI (Phase 2)
â”‚   â””â”€â”€ PluginEditor.cpp       # (Phase 2)
â”œâ”€â”€ reference-ui/              # Gemini's React/TypeScript prototype (reference only)
â”‚   â”œâ”€â”€ audio.ts               # DSP requirements
â”‚   â”œâ”€â”€ JUCE_MIGRATION_GUIDE.md  # Critical architectural rules
â”‚   â””â”€â”€ *.tsx                  # UI components
â”œâ”€â”€ docs/                      # Documentation
â”‚   â””â”€â”€ DEVELOPMENT_LOG.md     # Development journal
â”œâ”€â”€ TASKS/                     # Task management (Phase 2+)
â””â”€â”€ README.md                  # Project overview
```

---

## Critical Rules (from JUCE_MIGRATION_GUIDE.md)

1. **NEVER** allocate memory in processBlock()
2. **NEVER** use locks (std::mutex) in processBlock()
3. **NEVER** call UI functions from audio thread
4. **ALWAYS** use std::atomic<float> for scalar metrics
5. **ALWAYS** use lock-free FIFO for buffer data (FFT)
6. **ALWAYS** use juce::Timer (60Hz) for UI updates

---

## Session Recovery Instructions

When restoring this session:

1. **Verify Phase Status**: Check DEVELOPMENT_LOG.md for current phase
2. **Read Migration Guide**: Review reference-ui/JUCE_MIGRATION_GUIDE.md
3. **Check Git History**: `git log --oneline -10` for recent commits
4. **Resume Work**: Continue from last TODO in TASKS/ directory

---

## Key Learnings

- **From SPLENTA**: Commit message format (V0.x.x - YYYYMMDD.HH), .claude-context.md, TASKS/ structure
- **Thread Safety**: Circular buffer wrap-around handling in LUFS calculation
- **FFT Optimization**: In-place transform + lock-free FIFO push
- **Aesthetic Division**: Gemini handles UI, Claude handles DSP (established after æ·«çº¹äº‹ä»¶)

---

**Next Milestone**: Complete Phase 2 (UI Foundation) and create first functional build
